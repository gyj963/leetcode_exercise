### 我的思路
我最初写了个暴力的O(n2)解法，然后TLE了 (-.-||| 如果想看的话可以看代码中的解法二

然后我去研究了一下马拉车算法
先看了一下 https://www.hackerrank.com/topics/manachers-algorithm 
然后。。。没看懂(-.-|||

这个看懂了
有什么浅显易懂的Manacher Algorithm讲解？ - windliang的回答 - 知乎
https://www.zhihu.com/question/37289584/answer/465656849


自己整理一下思路：
比如当前字符串s为：
babad

先将s处理一下字符串前后加^和$，字符串中每个字符之间加#结果为T：
^#b#a#b#a#d#$
如此处理是为了保证所有回文串长度为奇数，因为之后需要记录以字符为中心的回文串长度，如果有回文串长度偶数的话，很难确定哪个字符是中心。

声明
let P = [] 记录以当前下标对应的字符为中心的回文串长度，
let C = 0 记录当前正在对比的中心字符下标
let R = 0 记录以C为中心的回文串的右边界（含边界字符）下标

遍历T每个字符，下标为i
如果右边界下标 > 当前下标i，则说明当前的字符在以C为中心的回文串之内，回文串内的字符有对称性，以c为中心的回文串中下标i对称的下标为i_mirror，P[i]=P[i_mirror]，
但如果R-i < P[i_mirror] 则说明以下标为i_mirror字符为中心的回文串左侧边界超出了C为中心的回文串，超出部分将不具有对称性，所以此时P[i]=R-i

P[i]在经过以上处理之后，得到了一个以i下标字符为中心的回文串长度，但此时的值可能不是最大值，需要扩展对比
当前回文串为下标i-P[i]～i+P[i]的字符串，对比下标为i-P[i]-1、i+P[i]+1是否相等，相等则将P[i]数值+1，反复对比直到i-P[i]-1、i+P[i]+1不相等

如果i下标字符为中心的回文串右边界下标 > R，则更新C = i、R = i+P[i]
遍历直到T中字符被遍历完毕

最后找到P中记录的数字的最大值maxLen，及对应的下标maxLenIndex
在s中左边界下标为Math.floor((maxLenIndex-maxLen)/2)，由此可得最长回文子串

下标为i
i  0 1 2 3 4 5 6 7 8 9 10 11 12
T  ^ # b # a # b # a # d  #  $ 
P  0 0 1 0 1 0 3 0 1 0 1  0  0

