### 我的思路
####  解法一
【时间复杂度较高】
先将无序数组排序，遍历有序数组。
将当前下标最长连续序列的长度记录在数组中，长度数组
如果当前数字数组下标指向的数字 = 数字数组下标-1指向的数字+1 则说明当前是连续序列，
当前长度数组下标指向的数字为（最长连续序列长度） = 长度数组下标-1指向的数字+1

如果当前数字数组下标指向的数字 != 数字数组下标-1指向的数字+1 
则当前长度数组下标指向的数字为（最长连续序列长度）= 1

注意边界处理（下标为0的情况，相邻两位数字相同情况）

取长度数组中最大值

####  解法二
【时间复杂度较低】
是我在看到其他人写的java代码后，重写的
将数组中所有数字放在set中，遍历set中的数字，
查询set中有无当前数字-1的数字，如果没有代表这是一个连续序列的第一个，记录当前数字，声明当前连续序列长度为1，将当前数字+1继续检查set中是否有该数字，直到set中查询不到该数字。并记录最大长度。
   
实现详情可见<a href="./Unique_Binary_Search_Trees.js">代码</a>